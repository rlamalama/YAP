# YAP Language Grammar Specification

This document describes the lexical structure and grammar of the YAP (YAML as Programming) language.

---

## 1. Lexical Analysis

A YAP program is read by a parser. Input to the parser is a stream of tokens generated by the lexical analyzer (lexer). This section describes how the lexer produces tokens from source text.

### 1.1. Source Encoding

YAP source files are read as UTF-8 encoded text.

### 1.2. Character Categories

| Character                  | Token Type / Behavior                |
|----------------------------|--------------------------------------|
| space (` `)                | Whitespace (ignored between tokens)  |
| tab (`\t`)                 | **Error** — tabs are not allowed     |
| newline (CR, LF, CRLF)     | `NEWLINE` token                      |
| dash (`-`)                 | `DASH` token                         |
| colon (`:`)                | `COLON` token                        |
| double quote (`"`)         | String literal delimiter             |
| letter (`a-z`, `A-Z`)      | Start of identifier or keyword       |
| underscore (`_`)           | Start of identifier                  |
| digit (`0-9`)              | Numeric literal                      |
| `+`, `-`, `*`, `/`         | `OPERATOR` token (arithmetic)        |
| `>`, `<`, `>=`, `<=`, `==`, `!=` | `OPERATOR` token (comparison)  |
| `//`                       | Comment start (rest of line ignored) |
| end of file                | `EOF` token                          |

---

## 2. Line Structure

YAP programs are structured using **indentation** (similar to Python and YAML). Indentation is significant and uses spaces only.

### 2.1. Physical Lines

A physical line is a sequence of characters terminated by:
- Unix-style: ASCII LF (linefeed)
- Windows-style: ASCII CR LF (carriage return + linefeed)

### 2.2. Blank Lines

Blank lines (lines containing only whitespace) are ignored by the lexer.

### 2.3. Comments

Comments begin with `//` and extend to the end of the line. They can appear:
- At the beginning of a line (full-line comment)
- After a statement on the same line (inline comment)
- Inside indented blocks

```yaml
// This is a full-line comment
- print: "hello"  // This is an inline comment

- set:
  - x: 10
  // - y: 5   <- This assignment is commented out
  - z: 20
```

Comments are tokenized as `COMMENT` tokens followed by `NEWLINE`, then discarded by the parser. Everything after `//` until the end of the line is ignored.

```
comment: "//" <any characters until newline>
```

### 2.4. Indentation

Indentation determines block structure. The lexer tracks indentation levels using a stack:

- **INDENT token**: Emitted when indentation increases from the previous level
- **DEDENT token**: Emitted when indentation decreases to a previous level

**Important**: Only spaces are allowed for indentation. Tab characters (`\t`) will cause a lexer error.

```
indentation: SPACE*
```

### 2.5. Whitespace Between Tokens

Spaces between tokens on the same line are ignored (except for indentation at the start of a line).

---

## 3. Tokens

The YAP lexer produces the following token types:

| Token Kind     | Description                                      |
|----------------|--------------------------------------------------|
| `DASH`         | The `-` character, starts a statement            |
| `IDENTIFIER`   | A name (variable, field name)                    |
| `KEYWORD`      | A reserved word (`print`, `set`, `True`, `False`)|
| `COLON`        | The `:` character                                |
| `OPERATOR`     | Arithmetic and comparison operators              |
| `STRING`       | A string literal enclosed in double quotes       |
| `NUMERICAL`    | An integer literal                               |
| `COMMENT`      | A comment starting with `//`                     |
| `INDENT`       | Increase in indentation level                    |
| `DEDENT`       | Decrease in indentation level                    |
| `NEWLINE`      | End of a logical line                            |
| `EOF`          | End of file                                      |

---

## 4. Keywords

Keywords are reserved identifiers with special meaning. They cannot be used as variable names.

| Keyword  | Description                        |
|----------|------------------------------------|
| `print`  | Output a value to the console      |
| `set`    | Assign values to variables         |
| `if`     | Conditional statement              |
| `then`   | True branch of if statement        |
| `else`   | False branch of if statement       |
| `True`   | Boolean literal (true)             |
| `False`  | Boolean literal (false)            |

Formally:

```
keyword: "print" | "set" | "if" | "then" | "else" | "True" | "False"
```

---

## 5. Identifiers

Identifiers are names used for variables and field names.

### 5.1. Definition

An identifier starts with a letter (`a-z`, `A-Z`) or underscore (`_`), followed by zero or more letters, digits (`0-9`), or underscores.

```
identifier:     letter (letter | digit)*
letter:         "a"..."z" | "A"..."Z" | "_"
digit:          "0"..."9"
```

### 5.2. Examples

Valid identifiers:
```
x
myVariable
_private
count2
MAX_VALUE
```

Invalid identifiers:
```
2fast       (starts with digit)
my-var      (contains hyphen)
```

---

## 6. Literals

YAP supports three types of literals: string literals, numeric literals, and boolean literals.

### 6.1. String Literals

String literals are sequences of characters enclosed in double quotes (`"`).

```
string_literal: '"' character* '"'
character:      <any character except '"' and newline>
```

**Note**: Strings must be on a single line. Unterminated strings (missing closing quote) will cause a lexer error.

#### Examples

```yaml
"hello world"
"YAP is fun!"
"123"
""
```

### 6.2. Numeric Literals

Numeric literals represent integer values. Currently, only non-negative integers are supported.

```
numeric_literal: digit+
digit:           "0"..."9"
```

#### Examples

```yaml
0
42
123456
```

**Note**: Floating-point numbers and negative numbers are not yet supported.

### 6.3. Boolean Literals

Boolean literals represent truth values.

```
boolean_literal: "True" | "False"
```

#### Examples

```yaml
True
False
```

**Note**: Boolean literals are case-sensitive. `true` and `false` (lowercase) are not valid boolean literals.

---

## 7. Operators and Delimiters

YAP uses the following operators and delimiters:

### 7.1. Delimiters

| Symbol | Name   | Usage                                    |
|--------|--------|------------------------------------------|
| `-`    | Dash   | Statement prefix                         |
| `:`    | Colon  | Separator between keyword/name and value |

### 7.2. Arithmetic Operators

Arithmetic operators are used in expressions to perform calculations.

| Symbol | Name           | Description                          |
|--------|----------------|--------------------------------------|
| `+`    | Addition       | Adds two numbers or concatenates strings |
| `-`    | Subtraction    | Subtracts right operand from left    |
| `*`    | Multiplication | Multiplies two numbers               |
| `/`    | Division       | Divides left operand by right (integer division) |

### 7.3. Comparison Operators

Comparison operators compare two values and return a boolean result (`True` or `False`).

| Symbol | Name                  | Description                          |
|--------|-----------------------|--------------------------------------|
| `>`    | Greater than          | True if left > right                 |
| `<`    | Less than             | True if left < right                 |
| `>=`   | Greater than or equal | True if left >= right                |
| `<=`   | Less than or equal    | True if left <= right                |
| `==`   | Equal                 | True if left equals right            |
| `!=`   | Not equal             | True if left does not equal right    |

```
arithmetic_operator: "+" | "-" | "*" | "/"
comparison_operator: ">" | "<" | ">=" | "<=" | "==" | "!="
operator: arithmetic_operator | comparison_operator
```

**Note**: Operators are evaluated left-to-right with no precedence rules currently. All operators have equal precedence.

---

## 8. Grammar

This section defines the formal grammar of YAP programs.

### 8.1. Notation

The grammar uses the following notation:
- `|` denotes alternatives
- `*` denotes zero or more repetitions
- `+` denotes one or more repetitions
- `?` denotes optional elements
- `UPPERCASE` denotes tokens
- `lowercase` denotes grammar rules

### 8.2. Program Structure

```
program:        statement*

statement:      DASH KEYWORD COLON statement_body NEWLINE

statement_body: print_body
              | set_body
              | if_body
```

### 8.3. Print Statement

The `print` statement outputs the result of an expression.

```
print_body:     expression
```

#### Syntax

```yaml
- print: <expression>
```

#### Examples

```yaml
- print: "hello world"
- print: 42
- print: myVariable
- print: 5 + 10
- print: x * 2
- print: "hello" + " " + "world"
- print: True
- print: 5 > 3
```

### 8.4. Set Statement

The `set` statement assigns the result of expressions to one or more variables.

```
set_body:       NEWLINE INDENT assignment+ DEDENT

assignment:     DASH IDENTIFIER COLON expression NEWLINE
```

#### Syntax

```yaml
- set:
  - <identifier>: <expression>
  - <identifier>: <expression>
  ...
```

#### Examples

```yaml
- set:
  - x: 5
  - name: "Alice"
  - count: 100

- set:
  - sum: 10 + 20
  - doubled: x * 2
  - greeting: "Hello" + " " + "World"
  - isValid: True
  - isGreater: x > 5
```

### 8.5. If Statement

The `if` statement conditionally executes a block of statements based on a boolean expression.

```
if_body:        expression NEWLINE INDENT then_clause else_clause? DEDENT

then_clause:    KEYWORD("then") COLON NEWLINE block

else_clause:    KEYWORD("else") COLON NEWLINE block

block:          INDENT statement* DEDENT
              | ε                           (empty block)
```

#### Syntax

```yaml
- if: <condition>
  then:
    <statements>
  else:
    <statements>
```

The `else` clause is optional. Both `then` and `else` blocks can be empty.

#### Examples

**Basic if-then-else:**

```yaml
- if: x > 5
  then:
    - print: "x is big"
  else:
    - print: "x is small"
```

**If without else:**

```yaml
- if: x > 0
  then:
    - print: "x is positive"
```

**Nested if statements:**

```yaml
- if: x > 5
  then:
    - print: "x is big"
    - if: x < 20
      then:
        - print: "but not that big"
      else:
        - print: "it's huge!"
  else:
    - print: "x is small"
```

**Empty blocks:**

```yaml
- if: x > 5
  then:
    - print: "x is big"
  else:
```

**Note**: The `then` and `else` keywords must appear inside the if statement's indented block and are not prefixed with a dash. A standalone `- then:` or `- else:` without a preceding `- if:` will cause a parse error.

### 8.7. Expressions

An expression produces a value. Expressions can be simple values or binary operations.

```
expression:     value (OPERATOR value)*

value:          STRING
              | NUMERICAL
              | IDENTIFIER
              | BOOLEAN
```

#### Binary Expressions

Binary expressions combine two values with an operator:

```yaml
5 + 10          # Numeric addition: 15
10 - 3          # Numeric subtraction: 7
4 * 5           # Numeric multiplication: 20
20 / 4          # Numeric division: 5
"hello" + " " + "world"   # String concatenation: "hello world"
```

#### Comparison Expressions

Comparison expressions compare values and return booleans:

```yaml
5 > 3           # True
10 < 5          # False
5 >= 5          # True
3 <= 2          # False
5 == 5          # True
5 != 3          # True
"abc" == "abc"  # True
"abc" != "xyz"  # True
True == True    # True
```

#### Chained Expressions

Multiple operators can be chained. They are evaluated left-to-right:

```yaml
10 + 5 - 3      # ((10 + 5) - 3) = 12
2 * 3 + 4       # ((2 * 3) + 4) = 10
```

**Note**: There is currently no operator precedence — all operators are evaluated left-to-right.

---

## 9. Complete Grammar Summary

```
program         ::= statement*

statement       ::= DASH KEYWORD COLON statement_body NEWLINE

statement_body  ::= print_body
                  | set_body
                  | if_body

print_body      ::= expression

set_body        ::= NEWLINE INDENT assignment+ DEDENT

assignment      ::= DASH IDENTIFIER COLON expression NEWLINE

if_body         ::= expression NEWLINE INDENT then_clause else_clause? DEDENT

then_clause     ::= KEYWORD("then") COLON NEWLINE block

else_clause     ::= KEYWORD("else") COLON NEWLINE block

block           ::= INDENT statement* DEDENT
                  | ε

expression      ::= value (OPERATOR value)*

value           ::= STRING
                  | NUMERICAL
                  | IDENTIFIER
                  | BOOLEAN

STRING          ::= '"' <characters> '"'
NUMERICAL       ::= digit+
IDENTIFIER      ::= letter (letter | digit)*
BOOLEAN         ::= "True" | "False"
KEYWORD         ::= "print" | "set" | "if" | "then" | "else" | "True" | "False"
OPERATOR        ::= "+" | "-" | "*" | "/" | ">" | "<" | ">=" | "<=" | "==" | "!="
COMMENT         ::= "//" <any characters until newline>

letter          ::= "a"..."z" | "A"..."Z" | "_"
digit           ::= "0"..."9"
```

---

## 10. Example Programs

### 10.1. Basic Example

```yaml
- set:
  - greeting: "Hello"
  - count: 5

- print: greeting
- print: count
- print: "Done!"
```

#### Token Stream

The above program produces the following token stream:

```
DASH KEYWORD("set") COLON NEWLINE
INDENT
  DASH IDENTIFIER("greeting") COLON STRING("Hello") NEWLINE
  DASH IDENTIFIER("count") COLON NUMERICAL("5") NEWLINE
DEDENT
DASH KEYWORD("print") COLON IDENTIFIER("greeting") NEWLINE
DASH KEYWORD("print") COLON IDENTIFIER("count") NEWLINE
DASH KEYWORD("print") COLON STRING("Done!") NEWLINE
EOF
```

### 10.2. Expressions Example

```yaml
- set:
  - x: 10 + 10 - 15
  - y: x * 4
  - z: y / 5

- print: x
- print: y
- print: x * z
```

#### Output

```
5
20
20
```

#### Explanation

1. `x` is set to `10 + 10 - 15` = `5`
2. `y` is set to `x * 4` = `5 * 4` = `20`
3. `z` is set to `y / 5` = `20 / 5` = `4`
4. Print `x` → `5`
5. Print `y` → `20`
6. Print `x * z` → `5 * 4` → `20`

### 10.3. Boolean and Comparison Example

```yaml
- set:
  - a: 10
  - b: 5
  - isGreater: a > b
  - isEqual: a == b
  - flag: True

- print: isGreater
- print: isEqual
- print: flag
- print: a >= 10
```

#### Output

```
true
false
true
true
```

### 10.4. Comments Example

```yaml
// Initialize variables
- set:
  - x: 10
  // - y: 5   <- commented out, y is not defined
  - z: 20

- print: x      // prints 10
- print: z      // prints 20
// - print: y   <- would error if uncommented (y undefined)
```

#### Output

```
10
20
```

#### Explanation

1. The first line is a full-line comment, ignored
2. Inside the set block, `- y: 5` is commented out, so `y` is never defined
3. `x` and `z` are set normally
4. The inline comments after print statements are ignored
5. The last line is commented out entirely

### 10.5. Conditional Example

```yaml
- set:
  - x: 10

- if: x > 5
  then:
    - print: "x is big"
    - if: x < 20
      then:
        - print: "well not that big"
      else:
        - print: "it must be huge!"
  else:
    - print: "x is small"
```

#### Output

```
x is big
well not that big
```

#### Explanation

1. `x` is set to `10`
2. `x > 5` evaluates to `True`, so the `then` block executes
3. First, `"x is big"` is printed
4. Then the nested if is evaluated: `x < 20` is `True`
5. So `"well not that big"` is printed
6. The outer `else` block is not executed

### 10.6. Conditional with Empty Blocks

```yaml
- set:
  - x: 10

- if: x > 5
  then:
    - print: "x is big"
  else:
```

#### Output

```
x is big
```

#### Explanation

1. `x > 5` is `True`, so the `then` block executes
2. The `else` block is empty and never executed
3. Empty blocks are valid and produce no output

---

## 11. Errors

The lexer, parser, and runtime will report errors for:

| Error Type              | Description                                       |
|-------------------------|---------------------------------------------------|
| Tab character           | Tabs are not allowed; use spaces for indentation  |
| Invalid indentation     | Indentation doesn't match any previous level      |
| Unterminated string     | String literal missing closing quote              |
| Invalid token           | Unrecognized character in source                  |
| Unexpected token        | Token not expected at current position            |
| Unknown statement       | Keyword not recognized (e.g., `- then:` or `- else:` without `- if:`) |
| Undefined variable      | Variable used before being defined                |
| Division by zero        | Attempt to divide by zero                         |
| Type mismatch           | Incompatible types in binary operation            |
| Invalid condition       | If condition does not evaluate to a boolean       |

---

## References

- Inspired by [Python Lexical Analysis](https://docs.python.org/3/reference/lexical_analysis.html)
- YAML specification for syntax inspiration

